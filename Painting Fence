// Painting Fence Algorithm (Ninja and The Fence on code360)

// Using Recursion + Memoization

#include <bits/stdc++.h> 
#define MOD 1000000007

int add(long long int a,long long int b){
    return (a%MOD + b%MOD)%MOD;
}

int mul(long long int a,long long int b){
    return (a%MOD * b%MOD)%MOD;
}

int solveMem(int n, int k, vector<int> & dp){
    if(n==1){
        return k;
    }
    if(n==2){
        return add(k,mul(k,k-1));
    }

    if(dp[n] != -1){
        return dp[n];
    }

    dp[n] = add(mul(solveMem(n-2,k,dp),k-1),mul(solveMem(n-1,k,dp),k-1));

    return dp[n];
}

int numberOfWays(int n, int k) {
     if (k == 1) {
         return (n <= 2) ? 1 : 0;
     }
     vector<int>dp(n+1,-1);

     int ans = solveMem(n,k,dp);

     return ans;
}

// Using Tabulation and Optimising the space

#include <bits/stdc++.h> 
#define MOD 1000000007

int add(long long int a,long long int b){
    return (a%MOD + b%MOD)%MOD;
}

int mul(long long int a,long long int b){
    return (a%MOD * b%MOD)%MOD;
}


int solveTab(int n, int k){
    long long int prev2 = k;
    long long int  prev1 = add(k,mul(k,k-1));


    for(int i = 3; i <=n ; i++){
        long long int  ans = add(mul(prev2,k-1),mul(prev1,k-1));
        prev2 = prev1;
        prev1 = ans;

    }
    return prev1;
}
int numberOfWays(int n, int k) {
    
    if (k == 1) {
    return (n <= 2) ? 1 : 0;
}


    return solveTab(n,k);
}
